{"version":3,"file":"explore.6b4e578487905110ad7c.js","sources":["webpack:///./public/app/containers/Explore/ElapsedTime.tsx","webpack:///./public/app/containers/Explore/Explore.tsx","webpack:///./public/app/containers/Explore/Graph.tsx","webpack:///./public/app/containers/Explore/Legend.tsx","webpack:///./public/app/containers/Explore/Logs.tsx","webpack:///./public/app/containers/Explore/PromQueryField.tsx","webpack:///./public/app/containers/Explore/QueryField.tsx","webpack:///./public/app/containers/Explore/QueryRows.tsx","webpack:///./public/app/containers/Explore/Table.tsx","webpack:///./public/app/containers/Explore/TimePicker.tsx","webpack:///./public/app/containers/Explore/Typeahead.tsx","webpack:///./public/app/containers/Explore/Wrapper.tsx","webpack:///./public/app/containers/Explore/slate-plugins/braces.ts","webpack:///./public/app/containers/Explore/slate-plugins/clear.ts","webpack:///./public/app/containers/Explore/slate-plugins/newline.ts","webpack:///./public/app/containers/Explore/slate-plugins/prism/index.tsx","webpack:///./public/app/containers/Explore/slate-plugins/prism/promql.ts","webpack:///./public/app/containers/Explore/slate-plugins/runner.ts","webpack:///./public/app/containers/Explore/utils/dom.ts","webpack:///./public/app/containers/Explore/utils/prometheus.ts","webpack:///./public/app/containers/Explore/utils/query.ts"],"sourcesContent":["import React, { PureComponent } from 'react';\n\nconst INTERVAL = 150;\n\nexport default class ElapsedTime extends PureComponent<any, any> {\n  offset: number;\n  timer: number;\n\n  state = {\n    elapsed: 0,\n  };\n\n  start() {\n    this.offset = Date.now();\n    this.timer = window.setInterval(this.tick, INTERVAL);\n  }\n\n  tick = () => {\n    const jetzt = Date.now();\n    const elapsed = jetzt - this.offset;\n    this.setState({ elapsed });\n  };\n\n  componentWillReceiveProps(nextProps) {\n    if (nextProps.time) {\n      clearInterval(this.timer);\n    } else if (this.props.time) {\n      this.start();\n    }\n  }\n\n  componentDidMount() {\n    this.start();\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.timer);\n  }\n\n  render() {\n    const { elapsed } = this.state;\n    const { className, time } = this.props;\n    const value = (time || elapsed) / 1000;\n    return <span className={`elapsed-time ${className}`}>{value.toFixed(1)}s</span>;\n  }\n}\n","import React from 'react';\nimport { hot } from 'react-hot-loader';\nimport Select from 'react-select';\n\nimport kbn from 'app/core/utils/kbn';\nimport colors from 'app/core/utils/colors';\nimport TimeSeries from 'app/core/time_series2';\nimport { decodePathComponent } from 'app/core/utils/location_util';\nimport { parse as parseDate } from 'app/core/utils/datemath';\n\nimport ElapsedTime from './ElapsedTime';\nimport QueryRows from './QueryRows';\nimport Graph from './Graph';\nimport Logs from './Logs';\nimport Table from './Table';\nimport TimePicker, { DEFAULT_RANGE } from './TimePicker';\nimport { ensureQueries, generateQueryKey, hasQuery } from './utils/query';\n\nfunction makeTimeSeriesList(dataList, options) {\n  return dataList.map((seriesData, index) => {\n    const datapoints = seriesData.datapoints || [];\n    const alias = seriesData.target;\n    const colorIndex = index % colors.length;\n    const color = colors[colorIndex];\n\n    const series = new TimeSeries({\n      datapoints,\n      alias,\n      color,\n      unit: seriesData.unit,\n    });\n\n    return series;\n  });\n}\n\nfunction parseInitialState(initial: string | undefined) {\n  if (initial) {\n    try {\n      const parsed = JSON.parse(decodePathComponent(initial));\n      return {\n        datasource: parsed.datasource,\n        queries: parsed.queries.map(q => q.query),\n        range: parsed.range,\n      };\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  return { datasource: null, queries: [], range: DEFAULT_RANGE };\n}\n\ninterface IExploreState {\n  datasource: any;\n  datasourceError: any;\n  datasourceLoading: boolean | null;\n  datasourceMissing: boolean;\n  graphResult: any;\n  initialDatasource?: string;\n  latency: number;\n  loading: any;\n  logsResult: any;\n  queries: any;\n  queryError: any;\n  range: any;\n  requestOptions: any;\n  showingGraph: boolean;\n  showingLogs: boolean;\n  showingTable: boolean;\n  supportsGraph: boolean | null;\n  supportsLogs: boolean | null;\n  supportsTable: boolean | null;\n  tableResult: any;\n}\n\nexport class Explore extends React.Component<any, IExploreState> {\n  el: any;\n\n  constructor(props) {\n    super(props);\n    const { datasource, queries, range } = parseInitialState(props.routeParams.state);\n    this.state = {\n      datasource: null,\n      datasourceError: null,\n      datasourceLoading: null,\n      datasourceMissing: false,\n      graphResult: null,\n      initialDatasource: datasource,\n      latency: 0,\n      loading: false,\n      logsResult: null,\n      queries: ensureQueries(queries),\n      queryError: null,\n      range: range || { ...DEFAULT_RANGE },\n      requestOptions: null,\n      showingGraph: true,\n      showingLogs: true,\n      showingTable: true,\n      supportsGraph: null,\n      supportsLogs: null,\n      supportsTable: null,\n      tableResult: null,\n      ...props.initialState,\n    };\n  }\n\n  async componentDidMount() {\n    const { datasourceSrv } = this.props;\n    const { initialDatasource } = this.state;\n    if (!datasourceSrv) {\n      throw new Error('No datasource service passed as props.');\n    }\n    const datasources = datasourceSrv.getExploreSources();\n    if (datasources.length > 0) {\n      this.setState({ datasourceLoading: true });\n      // Priority: datasource in url, default datasource, first explore datasource\n      let datasource;\n      if (initialDatasource) {\n        datasource = await datasourceSrv.get(initialDatasource);\n      } else {\n        datasource = await datasourceSrv.get();\n      }\n      if (!datasource.meta.explore) {\n        datasource = await datasourceSrv.get(datasources[0].name);\n      }\n      this.setDatasource(datasource);\n    } else {\n      this.setState({ datasourceMissing: true });\n    }\n  }\n\n  componentDidCatch(error) {\n    this.setState({ datasourceError: error });\n    console.error(error);\n  }\n\n  async setDatasource(datasource) {\n    const supportsGraph = datasource.meta.metrics;\n    const supportsLogs = datasource.meta.logs;\n    const supportsTable = datasource.meta.metrics;\n    let datasourceError = null;\n\n    try {\n      const testResult = await datasource.testDatasource();\n      datasourceError = testResult.status === 'success' ? null : testResult.message;\n    } catch (error) {\n      datasourceError = (error && error.statusText) || error;\n    }\n\n    this.setState(\n      {\n        datasource,\n        datasourceError,\n        supportsGraph,\n        supportsLogs,\n        supportsTable,\n        datasourceLoading: false,\n      },\n      () => datasourceError === null && this.handleSubmit()\n    );\n  }\n\n  getRef = el => {\n    this.el = el;\n  };\n\n  handleAddQueryRow = index => {\n    const { queries } = this.state;\n    const nextQueries = [\n      ...queries.slice(0, index + 1),\n      { query: '', key: generateQueryKey() },\n      ...queries.slice(index + 1),\n    ];\n    this.setState({ queries: nextQueries });\n  };\n\n  handleChangeDatasource = async option => {\n    this.setState({\n      datasource: null,\n      datasourceError: null,\n      datasourceLoading: true,\n      graphResult: null,\n      logsResult: null,\n      tableResult: null,\n    });\n    const datasource = await this.props.datasourceSrv.get(option.value);\n    this.setDatasource(datasource);\n  };\n\n  handleChangeQuery = (query, index) => {\n    const { queries } = this.state;\n    const nextQuery = {\n      ...queries[index],\n      query,\n    };\n    const nextQueries = [...queries];\n    nextQueries[index] = nextQuery;\n    this.setState({ queries: nextQueries });\n  };\n\n  handleChangeTime = nextRange => {\n    const range = {\n      from: nextRange.from,\n      to: nextRange.to,\n    };\n    this.setState({ range }, () => this.handleSubmit());\n  };\n\n  handleClickCloseSplit = () => {\n    const { onChangeSplit } = this.props;\n    if (onChangeSplit) {\n      onChangeSplit(false);\n    }\n  };\n\n  handleClickGraphButton = () => {\n    this.setState(state => ({ showingGraph: !state.showingGraph }));\n  };\n\n  handleClickLogsButton = () => {\n    this.setState(state => ({ showingLogs: !state.showingLogs }));\n  };\n\n  handleClickSplit = () => {\n    const { onChangeSplit } = this.props;\n    if (onChangeSplit) {\n      onChangeSplit(true, this.state);\n    }\n  };\n\n  handleClickTableButton = () => {\n    this.setState(state => ({ showingTable: !state.showingTable }));\n  };\n\n  handleRemoveQueryRow = index => {\n    const { queries } = this.state;\n    if (queries.length <= 1) {\n      return;\n    }\n    const nextQueries = [...queries.slice(0, index), ...queries.slice(index + 1)];\n    this.setState({ queries: nextQueries }, () => this.handleSubmit());\n  };\n\n  handleSubmit = () => {\n    const { showingLogs, showingGraph, showingTable, supportsGraph, supportsLogs, supportsTable } = this.state;\n    if (showingTable && supportsTable) {\n      this.runTableQuery();\n    }\n    if (showingGraph && supportsGraph) {\n      this.runGraphQuery();\n    }\n    if (showingLogs && supportsLogs) {\n      this.runLogsQuery();\n    }\n  };\n\n  buildQueryOptions(targetOptions: { format: string; instant?: boolean }) {\n    const { datasource, queries, range } = this.state;\n    const resolution = this.el.offsetWidth;\n    const absoluteRange = {\n      from: parseDate(range.from, false),\n      to: parseDate(range.to, true),\n    };\n    const { interval } = kbn.calculateInterval(absoluteRange, resolution, datasource.interval);\n    const targets = queries.map(q => ({\n      ...targetOptions,\n      expr: q.query,\n    }));\n    return {\n      interval,\n      range,\n      targets,\n    };\n  }\n\n  async runGraphQuery() {\n    const { datasource, queries } = this.state;\n    if (!hasQuery(queries)) {\n      return;\n    }\n    this.setState({ latency: 0, loading: true, graphResult: null, queryError: null });\n    const now = Date.now();\n    const options = this.buildQueryOptions({ format: 'time_series', instant: false });\n    try {\n      const res = await datasource.query(options);\n      const result = makeTimeSeriesList(res.data, options);\n      const latency = Date.now() - now;\n      this.setState({ latency, loading: false, graphResult: result, requestOptions: options });\n    } catch (response) {\n      console.error(response);\n      const queryError = response.data ? response.data.error : response;\n      this.setState({ loading: false, queryError });\n    }\n  }\n\n  async runTableQuery() {\n    const { datasource, queries } = this.state;\n    if (!hasQuery(queries)) {\n      return;\n    }\n    this.setState({ latency: 0, loading: true, queryError: null, tableResult: null });\n    const now = Date.now();\n    const options = this.buildQueryOptions({\n      format: 'table',\n      instant: true,\n    });\n    try {\n      const res = await datasource.query(options);\n      const tableModel = res.data[0];\n      const latency = Date.now() - now;\n      this.setState({ latency, loading: false, tableResult: tableModel, requestOptions: options });\n    } catch (response) {\n      console.error(response);\n      const queryError = response.data ? response.data.error : response;\n      this.setState({ loading: false, queryError });\n    }\n  }\n\n  async runLogsQuery() {\n    const { datasource, queries } = this.state;\n    if (!hasQuery(queries)) {\n      return;\n    }\n    this.setState({ latency: 0, loading: true, queryError: null, logsResult: null });\n    const now = Date.now();\n    const options = this.buildQueryOptions({\n      format: 'logs',\n    });\n\n    try {\n      const res = await datasource.query(options);\n      const logsData = res.data;\n      const latency = Date.now() - now;\n      this.setState({ latency, loading: false, logsResult: logsData, requestOptions: options });\n    } catch (response) {\n      console.error(response);\n      const queryError = response.data ? response.data.error : response;\n      this.setState({ loading: false, queryError });\n    }\n  }\n\n  request = url => {\n    const { datasource } = this.state;\n    return datasource.metadataRequest(url);\n  };\n\n  render() {\n    const { datasourceSrv, position, split } = this.props;\n    const {\n      datasource,\n      datasourceError,\n      datasourceLoading,\n      datasourceMissing,\n      graphResult,\n      latency,\n      loading,\n      logsResult,\n      queries,\n      queryError,\n      range,\n      requestOptions,\n      showingGraph,\n      showingLogs,\n      showingTable,\n      supportsGraph,\n      supportsLogs,\n      supportsTable,\n      tableResult,\n    } = this.state;\n    const showingBoth = showingGraph && showingTable;\n    const graphHeight = showingBoth ? '200px' : '400px';\n    const graphButtonActive = showingBoth || showingGraph ? 'active' : '';\n    const logsButtonActive = showingLogs ? 'active' : '';\n    const tableButtonActive = showingBoth || showingTable ? 'active' : '';\n    const exploreClass = split ? 'explore explore-split' : 'explore';\n    const datasources = datasourceSrv.getExploreSources().map(ds => ({\n      value: ds.name,\n      label: ds.name,\n    }));\n    const selectedDatasource = datasource ? datasource.name : undefined;\n\n    return (\n      <div className={exploreClass} ref={this.getRef}>\n        <div className=\"navbar\">\n          {position === 'left' ? (\n            <div>\n              <a className=\"navbar-page-btn\">\n                <i className=\"fa fa-rocket\" />\n                Explore\n              </a>\n            </div>\n          ) : (\n            <div className=\"navbar-buttons explore-first-button\">\n              <button className=\"btn navbar-button\" onClick={this.handleClickCloseSplit}>\n                Close Split\n              </button>\n            </div>\n          )}\n          {!datasourceMissing ? (\n            <div className=\"navbar-buttons\">\n              <Select\n                className=\"datasource-picker\"\n                clearable={false}\n                onChange={this.handleChangeDatasource}\n                options={datasources}\n                placeholder=\"Loading datasources...\"\n                value={selectedDatasource}\n              />\n            </div>\n          ) : null}\n          <div className=\"navbar__spacer\" />\n          {position === 'left' && !split ? (\n            <div className=\"navbar-buttons\">\n              <button className=\"btn navbar-button\" onClick={this.handleClickSplit}>\n                Split\n              </button>\n            </div>\n          ) : null}\n          <div className=\"navbar-buttons\">\n            {supportsGraph ? (\n              <button className={`btn navbar-button ${graphButtonActive}`} onClick={this.handleClickGraphButton}>\n                Graph\n              </button>\n            ) : null}\n            {supportsTable ? (\n              <button className={`btn navbar-button ${tableButtonActive}`} onClick={this.handleClickTableButton}>\n                Table\n              </button>\n            ) : null}\n            {supportsLogs ? (\n              <button className={`btn navbar-button ${logsButtonActive}`} onClick={this.handleClickLogsButton}>\n                Logs\n              </button>\n            ) : null}\n          </div>\n          <TimePicker range={range} onChangeTime={this.handleChangeTime} />\n          <div className=\"navbar-buttons relative\">\n            <button className=\"btn navbar-button--primary\" onClick={this.handleSubmit}>\n              Run Query <i className=\"fa fa-level-down run-icon\" />\n            </button>\n            {loading || latency ? <ElapsedTime time={latency} className=\"text-info\" /> : null}\n          </div>\n        </div>\n\n        {datasourceLoading ? <div className=\"explore-container\">Loading datasource...</div> : null}\n\n        {datasourceMissing ? (\n          <div className=\"explore-container\">Please add a datasource that supports Explore (e.g., Prometheus).</div>\n        ) : null}\n\n        {datasourceError ? (\n          <div className=\"explore-container\">Error connecting to datasource. [{datasourceError}]</div>\n        ) : null}\n\n        {datasource && !datasourceError ? (\n          <div className=\"explore-container\">\n            <QueryRows\n              queries={queries}\n              request={this.request}\n              onAddQueryRow={this.handleAddQueryRow}\n              onChangeQuery={this.handleChangeQuery}\n              onExecuteQuery={this.handleSubmit}\n              onRemoveQueryRow={this.handleRemoveQueryRow}\n            />\n            {queryError ? <div className=\"text-warning m-a-2\">{queryError}</div> : null}\n            <main className=\"m-t-2\">\n              {supportsGraph && showingGraph ? (\n                <Graph\n                  data={graphResult}\n                  id={`explore-graph-${position}`}\n                  options={requestOptions}\n                  height={graphHeight}\n                  split={split}\n                />\n              ) : null}\n              {supportsTable && showingTable ? <Table data={tableResult} className=\"m-t-3\" /> : null}\n              {supportsLogs && showingLogs ? <Logs data={logsResult} /> : null}\n            </main>\n          </div>\n        ) : null}\n      </div>\n    );\n  }\n}\n\nexport default hot(module)(Explore);\n","import $ from 'jquery';\nimport React, { Component } from 'react';\nimport moment from 'moment';\n\nimport 'vendor/flot/jquery.flot';\nimport 'vendor/flot/jquery.flot.time';\nimport * as dateMath from 'app/core/utils/datemath';\nimport TimeSeries from 'app/core/time_series2';\n\nimport Legend from './Legend';\n\n// Copied from graph.ts\nfunction time_format(ticks, min, max) {\n  if (min && max && ticks) {\n    var range = max - min;\n    var secPerTick = range / ticks / 1000;\n    var oneDay = 86400000;\n    var oneYear = 31536000000;\n\n    if (secPerTick <= 45) {\n      return '%H:%M:%S';\n    }\n    if (secPerTick <= 7200 || range <= oneDay) {\n      return '%H:%M';\n    }\n    if (secPerTick <= 80000) {\n      return '%m/%d %H:%M';\n    }\n    if (secPerTick <= 2419200 || range <= oneYear) {\n      return '%m/%d';\n    }\n    return '%Y-%m';\n  }\n\n  return '%H:%M';\n}\n\nconst FLOT_OPTIONS = {\n  legend: {\n    show: false,\n  },\n  series: {\n    lines: {\n      linewidth: 1,\n      zero: false,\n    },\n    shadowSize: 0,\n  },\n  grid: {\n    minBorderMargin: 0,\n    markings: [],\n    backgroundColor: null,\n    borderWidth: 0,\n    // hoverable: true,\n    clickable: true,\n    color: '#a1a1a1',\n    margin: { left: 0, right: 0 },\n    labelMarginX: 0,\n  },\n  // selection: {\n  //   mode: 'x',\n  //   color: '#666',\n  // },\n  // crosshair: {\n  //   mode: 'x',\n  // },\n};\n\nclass Graph extends Component<any, any> {\n  componentDidMount() {\n    this.draw();\n  }\n\n  componentDidUpdate(prevProps) {\n    if (\n      prevProps.data !== this.props.data ||\n      prevProps.options !== this.props.options ||\n      prevProps.split !== this.props.split ||\n      prevProps.height !== this.props.height\n    ) {\n      this.draw();\n    }\n  }\n\n  draw() {\n    const { data, options: userOptions } = this.props;\n    if (!data) {\n      return;\n    }\n    const series = data.map((ts: TimeSeries) => ({\n      color: ts.color,\n      label: ts.label,\n      data: ts.getFlotPairs('null'),\n    }));\n\n    const $el = $(`#${this.props.id}`);\n    const ticks = $el.width() / 100;\n    let { from, to } = userOptions.range;\n    if (!moment.isMoment(from)) {\n      from = dateMath.parse(from, false);\n    }\n    if (!moment.isMoment(to)) {\n      to = dateMath.parse(to, true);\n    }\n    const min = from.valueOf();\n    const max = to.valueOf();\n    const dynamicOptions = {\n      xaxis: {\n        mode: 'time',\n        min: min,\n        max: max,\n        label: 'Datetime',\n        ticks: ticks,\n        timeformat: time_format(ticks, min, max),\n      },\n    };\n    const options = {\n      ...FLOT_OPTIONS,\n      ...dynamicOptions,\n      ...userOptions,\n    };\n    $.plot($el, series, options);\n  }\n\n  render() {\n    const { data, height } = this.props;\n    return (\n      <div className=\"panel-container\">\n        <div id={this.props.id} className=\"explore-graph\" style={{ height }} />\n        <Legend data={data} />\n      </div>\n    );\n  }\n}\n\nexport default Graph;\n","import React, { PureComponent } from 'react';\n\nconst LegendItem = ({ series }) => (\n  <div className=\"graph-legend-series\">\n    <div className=\"graph-legend-icon\">\n      <i className=\"fa fa-minus pointer\" style={{ color: series.color }} />\n    </div>\n    <a className=\"graph-legend-alias pointer\">{series.alias}</a>\n  </div>\n);\n\nexport default class Legend extends PureComponent<any, any> {\n  render() {\n    const { className = '', data } = this.props;\n    const items = data || [];\n    return (\n      <div className={`${className} graph-legend ps`}>\n        {items.map(series => <LegendItem key={series.id} series={series} />)}\n      </div>\n    );\n  }\n}\n","import React, { Fragment, PureComponent } from 'react';\n\nimport { LogsModel, LogRow } from 'app/core/logs_model';\n\ninterface LogsProps {\n  className?: string;\n  data: LogsModel;\n}\n\nconst EXAMPLE_QUERY = '{job=\"default/prometheus\"}';\n\nconst Entry: React.SFC<LogRow> = props => {\n  const { entry, searchMatches } = props;\n  if (searchMatches && searchMatches.length > 0) {\n    let lastMatchEnd = 0;\n    const spans = searchMatches.reduce((acc, match, i) => {\n      // Insert non-match\n      if (match.start !== lastMatchEnd) {\n        acc.push(<>{entry.slice(lastMatchEnd, match.start)}</>);\n      }\n      // Match\n      acc.push(\n        <span className=\"logs-row-match-highlight\" title={`Matching expression: ${match.text}`}>\n          {entry.substr(match.start, match.length)}\n        </span>\n      );\n      lastMatchEnd = match.start + match.length;\n      // Non-matching end\n      if (i === searchMatches.length - 1) {\n        acc.push(<>{entry.slice(lastMatchEnd)}</>);\n      }\n      return acc;\n    }, []);\n    return <>{spans}</>;\n  }\n  return <>{props.entry}</>;\n};\n\nexport default class Logs extends PureComponent<LogsProps, any> {\n  render() {\n    const { className = '', data } = this.props;\n    const hasData = data && data.rows && data.rows.length > 0;\n    return (\n      <div className={`${className} logs`}>\n        {hasData ? (\n          <div className=\"logs-entries panel-container\">\n            {data.rows.map(row => (\n              <Fragment key={row.key}>\n                <div className={row.logLevel ? `logs-row-level logs-row-level-${row.logLevel}` : ''} />\n                <div title={`${row.timestamp} (${row.timeFromNow})`}>{row.timeLocal}</div>\n                <div>\n                  <Entry {...row} />\n                </div>\n              </Fragment>\n            ))}\n          </div>\n        ) : null}\n        {!hasData ? (\n          <div className=\"panel-container\">\n            Enter a query like <code>{EXAMPLE_QUERY}</code>\n          </div>\n        ) : null}\n      </div>\n    );\n  }\n}\n","import _ from 'lodash';\nimport React from 'react';\n\n// dom also includes Element polyfills\nimport { getNextCharacter, getPreviousCousin } from './utils/dom';\nimport PluginPrism, { setPrismTokens } from './slate-plugins/prism/index';\nimport PrismPromql, { FUNCTIONS } from './slate-plugins/prism/promql';\nimport RunnerPlugin from './slate-plugins/runner';\nimport { processLabels, RATE_RANGES, cleanText } from './utils/prometheus';\n\nimport TypeaheadField, {\n  Suggestion,\n  SuggestionGroup,\n  TypeaheadInput,\n  TypeaheadFieldState,\n  TypeaheadOutput,\n} from './QueryField';\n\nconst EMPTY_METRIC = '';\nconst METRIC_MARK = 'metric';\nconst PRISM_LANGUAGE = 'promql';\n\nexport const wrapLabel = label => ({ label });\nexport const setFunctionMove = (suggestion: Suggestion): Suggestion => {\n  suggestion.move = -1;\n  return suggestion;\n};\n\nexport function willApplySuggestion(\n  suggestion: string,\n  { typeaheadContext, typeaheadText }: TypeaheadFieldState\n): string {\n  // Modify suggestion based on context\n  switch (typeaheadContext) {\n    case 'context-labels': {\n      const nextChar = getNextCharacter();\n      if (!nextChar || nextChar === '}' || nextChar === ',') {\n        suggestion += '=';\n      }\n      break;\n    }\n\n    case 'context-label-values': {\n      // Always add quotes and remove existing ones instead\n      if (!(typeaheadText.startsWith('=\"') || typeaheadText.startsWith('\"'))) {\n        suggestion = `\"${suggestion}`;\n      }\n      if (getNextCharacter() !== '\"') {\n        suggestion = `${suggestion}\"`;\n      }\n      break;\n    }\n\n    default:\n  }\n  return suggestion;\n}\n\ninterface PromQueryFieldProps {\n  initialQuery?: string | null;\n  labelKeys?: { [index: string]: string[] }; // metric -> [labelKey,...]\n  labelValues?: { [index: string]: { [index: string]: string[] } }; // metric -> labelKey -> [labelValue,...]\n  metrics?: string[];\n  onPressEnter?: () => void;\n  onQueryChange?: (value: string) => void;\n  portalPrefix?: string;\n  request?: (url: string) => any;\n}\n\ninterface PromQueryFieldState {\n  labelKeys: { [index: string]: string[] }; // metric -> [labelKey,...]\n  labelValues: { [index: string]: { [index: string]: string[] } }; // metric -> labelKey -> [labelValue,...]\n  metrics: string[];\n}\n\ninterface PromTypeaheadInput {\n  text: string;\n  prefix: string;\n  wrapperClasses: string[];\n  metric?: string;\n  labelKey?: string;\n}\n\nclass PromQueryField extends React.Component<PromQueryFieldProps, PromQueryFieldState> {\n  plugins: any[];\n\n  constructor(props, context) {\n    super(props, context);\n\n    this.plugins = [\n      RunnerPlugin({ handler: props.onPressEnter }),\n      PluginPrism({ definition: PrismPromql, language: PRISM_LANGUAGE }),\n    ];\n\n    this.state = {\n      labelKeys: props.labelKeys || {},\n      labelValues: props.labelValues || {},\n      metrics: props.metrics || [],\n    };\n  }\n\n  componentDidMount() {\n    this.fetchMetricNames();\n  }\n\n  onChangeQuery = value => {\n    // Send text change to parent\n    const { onQueryChange } = this.props;\n    if (onQueryChange) {\n      onQueryChange(value);\n    }\n  };\n\n  onReceiveMetrics = () => {\n    if (!this.state.metrics) {\n      return;\n    }\n    setPrismTokens(PRISM_LANGUAGE, METRIC_MARK, this.state.metrics);\n  };\n\n  onTypeahead = (typeahead: TypeaheadInput): TypeaheadOutput => {\n    const { editorNode, prefix, text, wrapperNode } = typeahead;\n\n    // Get DOM-dependent context\n    const wrapperClasses = Array.from(wrapperNode.classList);\n    // Take first metric as lucky guess\n    const metricNode = editorNode.querySelector(`.${METRIC_MARK}`);\n    const metric = metricNode && metricNode.textContent;\n    const labelKeyNode = getPreviousCousin(wrapperNode, '.attr-name');\n    const labelKey = labelKeyNode && labelKeyNode.textContent;\n\n    const result = this.getTypeahead({ text, prefix, wrapperClasses, metric, labelKey });\n\n    console.log('handleTypeahead', wrapperClasses, text, prefix, result.context);\n\n    return result;\n  };\n\n  // Keep this DOM-free for testing\n  getTypeahead({ prefix, wrapperClasses, metric, text }: PromTypeaheadInput): TypeaheadOutput {\n    // Determine candidates by CSS context\n    if (_.includes(wrapperClasses, 'context-range')) {\n      // Suggestions for metric[|]\n      return this.getRangeTypeahead();\n    } else if (_.includes(wrapperClasses, 'context-labels')) {\n      // Suggestions for metric{|} and metric{foo=|}, as well as metric-independent label queries like {|}\n      return this.getLabelTypeahead.apply(this, arguments);\n    } else if (metric && _.includes(wrapperClasses, 'context-aggregation')) {\n      return this.getAggregationTypeahead.apply(this, arguments);\n    } else if (\n      // Non-empty but not inside known token unless it's a metric\n      (prefix && !_.includes(wrapperClasses, 'token')) ||\n      prefix === metric ||\n      (prefix === '' && !text.match(/^[)\\s]+$/)) || // Empty context or after ')'\n      text.match(/[+\\-*/^%]/) // After binary operator\n    ) {\n      return this.getEmptyTypeahead();\n    }\n\n    return {\n      suggestions: [],\n    };\n  }\n\n  getEmptyTypeahead(): TypeaheadOutput {\n    const suggestions: SuggestionGroup[] = [];\n    suggestions.push({\n      prefixMatch: true,\n      label: 'Functions',\n      items: FUNCTIONS.map(setFunctionMove),\n    });\n\n    if (this.state.metrics) {\n      suggestions.push({\n        label: 'Metrics',\n        items: this.state.metrics.map(wrapLabel),\n      });\n    }\n    return { suggestions };\n  }\n\n  getRangeTypeahead(): TypeaheadOutput {\n    return {\n      context: 'context-range',\n      suggestions: [\n        {\n          label: 'Range vector',\n          items: [...RATE_RANGES].map(wrapLabel),\n        },\n      ],\n    };\n  }\n\n  getAggregationTypeahead({ metric }: PromTypeaheadInput): TypeaheadOutput {\n    let refresher: Promise<any> = null;\n    const suggestions: SuggestionGroup[] = [];\n    const labelKeys = this.state.labelKeys[metric];\n    if (labelKeys) {\n      suggestions.push({ label: 'Labels', items: labelKeys.map(wrapLabel) });\n    } else {\n      refresher = this.fetchMetricLabels(metric);\n    }\n\n    return {\n      refresher,\n      suggestions,\n      context: 'context-aggregation',\n    };\n  }\n\n  getLabelTypeahead({ metric, text, wrapperClasses, labelKey }: PromTypeaheadInput): TypeaheadOutput {\n    let context: string;\n    let refresher: Promise<any> = null;\n    const suggestions: SuggestionGroup[] = [];\n    if (metric) {\n      const labelKeys = this.state.labelKeys[metric];\n      if (labelKeys) {\n        if ((text && text.startsWith('=')) || _.includes(wrapperClasses, 'attr-value')) {\n          // Label values\n          if (labelKey) {\n            const labelValues = this.state.labelValues[metric][labelKey];\n            context = 'context-label-values';\n            suggestions.push({\n              label: 'Label values',\n              items: labelValues.map(wrapLabel),\n            });\n          }\n        } else {\n          // Label keys\n          context = 'context-labels';\n          suggestions.push({ label: 'Labels', items: labelKeys.map(wrapLabel) });\n        }\n      } else {\n        refresher = this.fetchMetricLabels(metric);\n      }\n    } else {\n      // Metric-independent label queries\n      const defaultKeys = ['job', 'instance'];\n      // Munge all keys that we have seen together\n      const labelKeys = Object.keys(this.state.labelKeys).reduce((acc, metric) => {\n        return acc.concat(this.state.labelKeys[metric].filter(key => acc.indexOf(key) === -1));\n      }, defaultKeys);\n      if ((text && text.startsWith('=')) || _.includes(wrapperClasses, 'attr-value')) {\n        // Label values\n        if (labelKey) {\n          if (this.state.labelValues[EMPTY_METRIC]) {\n            const labelValues = this.state.labelValues[EMPTY_METRIC][labelKey];\n            context = 'context-label-values';\n            suggestions.push({\n              label: 'Label values',\n              items: labelValues.map(wrapLabel),\n            });\n          } else {\n            // Can only query label values for now (API to query keys is under development)\n            refresher = this.fetchLabelValues(labelKey);\n          }\n        }\n      } else {\n        // Label keys\n        context = 'context-labels';\n        suggestions.push({ label: 'Labels', items: labelKeys.map(wrapLabel) });\n      }\n    }\n    return { context, refresher, suggestions };\n  }\n\n  request = url => {\n    if (this.props.request) {\n      return this.props.request(url);\n    }\n    return fetch(url);\n  };\n\n  async fetchLabelValues(key) {\n    const url = `/api/v1/label/${key}/values`;\n    try {\n      const res = await this.request(url);\n      const body = await (res.data || res.json());\n      const pairs = this.state.labelValues[EMPTY_METRIC];\n      const values = {\n        ...pairs,\n        [key]: body.data,\n      };\n      const labelValues = {\n        ...this.state.labelValues,\n        [EMPTY_METRIC]: values,\n      };\n      this.setState({ labelValues });\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  async fetchMetricLabels(name) {\n    const url = `/api/v1/series?match[]=${name}`;\n    try {\n      const res = await this.request(url);\n      const body = await (res.data || res.json());\n      const { keys, values } = processLabels(body.data);\n      const labelKeys = {\n        ...this.state.labelKeys,\n        [name]: keys,\n      };\n      const labelValues = {\n        ...this.state.labelValues,\n        [name]: values,\n      };\n      this.setState({ labelKeys, labelValues });\n    } catch (e) {\n      console.error(e);\n    }\n  }\n\n  async fetchMetricNames() {\n    const url = '/api/v1/label/__name__/values';\n    try {\n      const res = await this.request(url);\n      const body = await (res.data || res.json());\n      this.setState({ metrics: body.data }, this.onReceiveMetrics);\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  render() {\n    return (\n      <TypeaheadField\n        additionalPlugins={this.plugins}\n        cleanText={cleanText}\n        initialValue={this.props.initialQuery}\n        onTypeahead={this.onTypeahead}\n        onWillApplySuggestion={willApplySuggestion}\n        onValueChanged={this.onChangeQuery}\n        placeholder=\"Enter a PromQL query\"\n      />\n    );\n  }\n}\n\nexport default PromQueryField;\n","import _ from 'lodash';\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Block, Change, Document, Text, Value } from 'slate';\nimport { Editor } from 'slate-react';\nimport Plain from 'slate-plain-serializer';\n\nimport BracesPlugin from './slate-plugins/braces';\nimport ClearPlugin from './slate-plugins/clear';\nimport NewlinePlugin from './slate-plugins/newline';\n\nimport Typeahead from './Typeahead';\n\nexport const TYPEAHEAD_DEBOUNCE = 300;\n\nfunction flattenSuggestions(s: any[]): any[] {\n  return s ? s.reduce((acc, g) => acc.concat(g.items), []) : [];\n}\n\nexport const makeFragment = (text: string): Document => {\n  const lines = text.split('\\n').map(line =>\n    Block.create({\n      type: 'paragraph',\n      nodes: [Text.create(line)],\n    })\n  );\n\n  const fragment = Document.create({\n    nodes: lines,\n  });\n  return fragment;\n};\n\nexport const getInitialValue = (value: string): Value => Value.create({ document: makeFragment(value) });\n\nexport interface Suggestion {\n  /**\n   * The label of this completion item. By default\n   * this is also the text that is inserted when selecting\n   * this completion.\n   */\n  label: string;\n  /**\n   * The kind of this completion item. Based on the kind\n   * an icon is chosen by the editor.\n   */\n  kind?: string;\n  /**\n   * A human-readable string with additional information\n   * about this item, like type or symbol information.\n   */\n  detail?: string;\n  /**\n   * A human-readable string, can be Markdown, that represents a doc-comment.\n   */\n  documentation?: string;\n  /**\n   * A string that should be used when comparing this item\n   * with other items. When `falsy` the `label` is used.\n   */\n  sortText?: string;\n  /**\n   * A string that should be used when filtering a set of\n   * completion items. When `falsy` the `label` is used.\n   */\n  filterText?: string;\n  /**\n   * A string or snippet that should be inserted in a document when selecting\n   * this completion. When `falsy` the `label` is used.\n   */\n  insertText?: string;\n  /**\n   * Delete number of characters before the caret position,\n   * by default the letters from the beginning of the word.\n   */\n  deleteBackwards?: number;\n  /**\n   * Number of steps to move after the insertion, can be negative.\n   */\n  move?: number;\n}\n\nexport interface SuggestionGroup {\n  /**\n   * Label that will be displayed for all entries of this group.\n   */\n  label: string;\n  /**\n   * List of suggestions of this group.\n   */\n  items: Suggestion[];\n  /**\n   * If true, match only by prefix (and not mid-word).\n   */\n  prefixMatch?: boolean;\n  /**\n   * If true, do not filter items in this group based on the search.\n   */\n  skipFilter?: boolean;\n}\n\ninterface TypeaheadFieldProps {\n  additionalPlugins?: any[];\n  cleanText?: (text: string) => string;\n  initialValue: string | null;\n  onBlur?: () => void;\n  onFocus?: () => void;\n  onTypeahead?: (typeahead: TypeaheadInput) => TypeaheadOutput;\n  onValueChanged?: (value: Value) => void;\n  onWillApplySuggestion?: (suggestion: string, state: TypeaheadFieldState) => string;\n  placeholder?: string;\n  portalPrefix?: string;\n}\n\nexport interface TypeaheadFieldState {\n  suggestions: SuggestionGroup[];\n  typeaheadContext: string | null;\n  typeaheadIndex: number;\n  typeaheadPrefix: string;\n  typeaheadText: string;\n  value: Value;\n}\n\nexport interface TypeaheadInput {\n  editorNode: Element;\n  prefix: string;\n  selection?: Selection;\n  text: string;\n  wrapperNode: Element;\n}\n\nexport interface TypeaheadOutput {\n  context?: string;\n  refresher?: Promise<{}>;\n  suggestions: SuggestionGroup[];\n}\n\nclass QueryField extends React.Component<TypeaheadFieldProps, TypeaheadFieldState> {\n  menuEl: HTMLElement | null;\n  plugins: any[];\n  resetTimer: any;\n\n  constructor(props, context) {\n    super(props, context);\n\n    // Base plugins\n    this.plugins = [BracesPlugin(), ClearPlugin(), NewlinePlugin(), ...props.additionalPlugins];\n\n    this.state = {\n      suggestions: [],\n      typeaheadContext: null,\n      typeaheadIndex: 0,\n      typeaheadPrefix: '',\n      typeaheadText: '',\n      value: getInitialValue(props.initialValue || ''),\n    };\n  }\n\n  componentDidMount() {\n    this.updateMenu();\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.resetTimer);\n  }\n\n  componentDidUpdate() {\n    this.updateMenu();\n  }\n\n  componentWillReceiveProps(nextProps) {\n    // initialValue is null in case the user typed\n    if (nextProps.initialValue !== null && nextProps.initialValue !== this.props.initialValue) {\n      this.setState({ value: getInitialValue(nextProps.initialValue) });\n    }\n  }\n\n  onChange = ({ value }) => {\n    const changed = value.document !== this.state.value.document;\n    this.setState({ value }, () => {\n      if (changed) {\n        this.handleChangeValue();\n      }\n    });\n\n    if (changed) {\n      window.requestAnimationFrame(this.handleTypeahead);\n    }\n  };\n\n  handleChangeValue = () => {\n    // Send text change to parent\n    const { onValueChanged } = this.props;\n    if (onValueChanged) {\n      onValueChanged(Plain.serialize(this.state.value));\n    }\n  };\n\n  handleTypeahead = _.debounce(async () => {\n    const selection = window.getSelection();\n    const { cleanText, onTypeahead } = this.props;\n\n    if (onTypeahead && selection.anchorNode) {\n      const wrapperNode = selection.anchorNode.parentElement;\n      const editorNode = wrapperNode.closest('.slate-query-field');\n      if (!editorNode || this.state.value.isBlurred) {\n        // Not inside this editor\n        return;\n      }\n\n      const range = selection.getRangeAt(0);\n      const offset = range.startOffset;\n      const text = selection.anchorNode.textContent;\n      let prefix = text.substr(0, offset);\n      if (cleanText) {\n        prefix = cleanText(prefix);\n      }\n\n      const { suggestions, context, refresher } = onTypeahead({\n        editorNode,\n        prefix,\n        selection,\n        text,\n        wrapperNode,\n      });\n\n      const filteredSuggestions = suggestions\n        .map(group => {\n          if (group.items) {\n            if (prefix) {\n              // Filter groups based on prefix\n              if (!group.skipFilter) {\n                group.items = group.items.filter(c => (c.filterText || c.label).length >= prefix.length);\n                if (group.prefixMatch) {\n                  group.items = group.items.filter(c => (c.filterText || c.label).indexOf(prefix) === 0);\n                } else {\n                  group.items = group.items.filter(c => (c.filterText || c.label).indexOf(prefix) > -1);\n                }\n              }\n              // Filter out the already typed value (prefix) unless it inserts custom text\n              group.items = group.items.filter(c => c.insertText || (c.filterText || c.label) !== prefix);\n            }\n\n            group.items = _.sortBy(group.items, item => item.sortText || item.label);\n          }\n          return group;\n        })\n        .filter(group => group.items && group.items.length > 0); // Filter out empty groups\n\n      this.setState(\n        {\n          suggestions: filteredSuggestions,\n          typeaheadPrefix: prefix,\n          typeaheadContext: context,\n          typeaheadText: text,\n        },\n        () => {\n          if (refresher) {\n            refresher.then(this.handleTypeahead).catch(e => console.error(e));\n          }\n        }\n      );\n    }\n  }, TYPEAHEAD_DEBOUNCE);\n\n  applyTypeahead(change: Change, suggestion: Suggestion): Change {\n    const { cleanText, onWillApplySuggestion } = this.props;\n    const { typeaheadPrefix, typeaheadText } = this.state;\n    let suggestionText = suggestion.insertText || suggestion.label;\n    const move = suggestion.move || 0;\n\n    if (onWillApplySuggestion) {\n      suggestionText = onWillApplySuggestion(suggestionText, { ...this.state });\n    }\n\n    this.resetTypeahead();\n\n    // Remove the current, incomplete text and replace it with the selected suggestion\n    const backward = suggestion.deleteBackwards || typeaheadPrefix.length;\n    const text = cleanText ? cleanText(typeaheadText) : typeaheadText;\n    const suffixLength = text.length - typeaheadPrefix.length;\n    const offset = typeaheadText.indexOf(typeaheadPrefix);\n    const midWord = typeaheadPrefix && ((suffixLength > 0 && offset > -1) || suggestionText === typeaheadText);\n    const forward = midWord ? suffixLength + offset : 0;\n\n    // If new-lines, apply suggestion as block\n    if (suggestionText.match(/\\n/)) {\n      const fragment = makeFragment(suggestionText);\n      return change\n        .deleteBackward(backward)\n        .deleteForward(forward)\n        .insertFragment(fragment)\n        .focus();\n    }\n\n    return change\n      .deleteBackward(backward)\n      .deleteForward(forward)\n      .insertText(suggestionText)\n      .move(move)\n      .focus();\n  }\n\n  onKeyDown = (event, change) => {\n    const { typeaheadIndex, suggestions } = this.state;\n\n    switch (event.key) {\n      case 'Escape': {\n        if (this.menuEl) {\n          event.preventDefault();\n          event.stopPropagation();\n          this.resetTypeahead();\n          return true;\n        }\n        break;\n      }\n\n      case ' ': {\n        if (event.ctrlKey) {\n          event.preventDefault();\n          this.handleTypeahead();\n          return true;\n        }\n        break;\n      }\n\n      case 'Tab': {\n        if (this.menuEl) {\n          // Dont blur input\n          event.preventDefault();\n          if (!suggestions || suggestions.length === 0) {\n            return undefined;\n          }\n\n          // Get the currently selected suggestion\n          const flattenedSuggestions = flattenSuggestions(suggestions);\n          const selected = Math.abs(typeaheadIndex);\n          const selectedIndex = selected % flattenedSuggestions.length || 0;\n          const suggestion = flattenedSuggestions[selectedIndex];\n\n          this.applyTypeahead(change, suggestion);\n          return true;\n        }\n        break;\n      }\n\n      case 'ArrowDown': {\n        if (this.menuEl) {\n          // Select next suggestion\n          event.preventDefault();\n          this.setState({ typeaheadIndex: typeaheadIndex + 1 });\n        }\n        break;\n      }\n\n      case 'ArrowUp': {\n        if (this.menuEl) {\n          // Select previous suggestion\n          event.preventDefault();\n          this.setState({ typeaheadIndex: Math.max(0, typeaheadIndex - 1) });\n        }\n        break;\n      }\n\n      default: {\n        // console.log('default key', event.key, event.which, event.charCode, event.locale, data.key);\n        break;\n      }\n    }\n    return undefined;\n  };\n\n  resetTypeahead = () => {\n    this.setState({\n      suggestions: [],\n      typeaheadIndex: 0,\n      typeaheadPrefix: '',\n      typeaheadContext: null,\n    });\n  };\n\n  handleBlur = () => {\n    const { onBlur } = this.props;\n    // If we dont wait here, menu clicks wont work because the menu\n    // will be gone.\n    this.resetTimer = setTimeout(this.resetTypeahead, 100);\n    if (onBlur) {\n      onBlur();\n    }\n  };\n\n  handleFocus = () => {\n    const { onFocus } = this.props;\n    if (onFocus) {\n      onFocus();\n    }\n  };\n\n  onClickMenu = (item: Suggestion) => {\n    // Manually triggering change\n    const change = this.applyTypeahead(this.state.value.change(), item);\n    this.onChange(change);\n  };\n\n  updateMenu = () => {\n    const { suggestions } = this.state;\n    const menu = this.menuEl;\n    const selection = window.getSelection();\n    const node = selection.anchorNode;\n\n    // No menu, nothing to do\n    if (!menu) {\n      return;\n    }\n\n    // No suggestions or blur, remove menu\n    const hasSuggesstions = suggestions && suggestions.length > 0;\n    if (!hasSuggesstions) {\n      menu.removeAttribute('style');\n      return;\n    }\n\n    // Align menu overlay to editor node\n    if (node) {\n      // Read from DOM\n      const rect = node.parentElement.getBoundingClientRect();\n      const scrollX = window.scrollX;\n      const scrollY = window.scrollY;\n\n      // Write DOM\n      requestAnimationFrame(() => {\n        menu.style.opacity = '1';\n        menu.style.top = `${rect.top + scrollY + rect.height + 4}px`;\n        menu.style.left = `${rect.left + scrollX - 2}px`;\n      });\n    }\n  };\n\n  menuRef = el => {\n    this.menuEl = el;\n  };\n\n  renderMenu = () => {\n    const { portalPrefix } = this.props;\n    const { suggestions } = this.state;\n    const hasSuggesstions = suggestions && suggestions.length > 0;\n    if (!hasSuggesstions) {\n      return null;\n    }\n\n    // Guard selectedIndex to be within the length of the suggestions\n    let selectedIndex = Math.max(this.state.typeaheadIndex, 0);\n    const flattenedSuggestions = flattenSuggestions(suggestions);\n    selectedIndex = selectedIndex % flattenedSuggestions.length || 0;\n    const selectedItem: Suggestion | null =\n      flattenedSuggestions.length > 0 ? flattenedSuggestions[selectedIndex] : null;\n\n    // Create typeahead in DOM root so we can later position it absolutely\n    return (\n      <Portal prefix={portalPrefix}>\n        <Typeahead\n          menuRef={this.menuRef}\n          selectedItem={selectedItem}\n          onClickItem={this.onClickMenu}\n          groupedItems={suggestions}\n        />\n      </Portal>\n    );\n  };\n\n  render() {\n    return (\n      <div className=\"slate-query-field\">\n        {this.renderMenu()}\n        <Editor\n          autoCorrect={false}\n          onBlur={this.handleBlur}\n          onKeyDown={this.onKeyDown}\n          onChange={this.onChange}\n          onFocus={this.handleFocus}\n          placeholder={this.props.placeholder}\n          plugins={this.plugins}\n          spellCheck={false}\n          value={this.state.value}\n        />\n      </div>\n    );\n  }\n}\n\nclass Portal extends React.Component<{ index?: number; prefix: string }, {}> {\n  node: HTMLElement;\n\n  constructor(props) {\n    super(props);\n    const { index = 0, prefix = 'query' } = props;\n    this.node = document.createElement('div');\n    this.node.classList.add(`slate-typeahead`, `slate-typeahead-${prefix}-${index}`);\n    document.body.appendChild(this.node);\n  }\n\n  componentWillUnmount() {\n    document.body.removeChild(this.node);\n  }\n\n  render() {\n    return ReactDOM.createPortal(this.props.children, this.node);\n  }\n}\n\nexport default QueryField;\n","import React, { PureComponent } from 'react';\n\nimport QueryField from './PromQueryField';\n\nclass QueryRow extends PureComponent<any, any> {\n  constructor(props) {\n    super(props);\n    this.state = {\n      edited: false,\n      query: props.query || '',\n    };\n  }\n\n  handleChangeQuery = value => {\n    const { index, onChangeQuery } = this.props;\n    const { query } = this.state;\n    const edited = query !== value;\n    this.setState({ edited, query: value });\n    if (onChangeQuery) {\n      onChangeQuery(value, index);\n    }\n  };\n\n  handleClickAddButton = () => {\n    const { index, onAddQueryRow } = this.props;\n    if (onAddQueryRow) {\n      onAddQueryRow(index);\n    }\n  };\n\n  handleClickRemoveButton = () => {\n    const { index, onRemoveQueryRow } = this.props;\n    if (onRemoveQueryRow) {\n      onRemoveQueryRow(index);\n    }\n  };\n\n  handlePressEnter = () => {\n    const { onExecuteQuery } = this.props;\n    if (onExecuteQuery) {\n      onExecuteQuery();\n    }\n  };\n\n  render() {\n    const { request } = this.props;\n    const { edited, query } = this.state;\n    return (\n      <div className=\"query-row\">\n        <div className=\"query-row-tools\">\n          <button className=\"btn navbar-button navbar-button--tight\" onClick={this.handleClickAddButton}>\n            <i className=\"fa fa-plus\" />\n          </button>\n          <button className=\"btn navbar-button navbar-button--tight\" onClick={this.handleClickRemoveButton}>\n            <i className=\"fa fa-minus\" />\n          </button>\n        </div>\n        <div className=\"slate-query-field-wrapper\">\n          <QueryField\n            initialQuery={edited ? null : query}\n            portalPrefix=\"explore\"\n            onPressEnter={this.handlePressEnter}\n            onQueryChange={this.handleChangeQuery}\n            request={request}\n          />\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default class QueryRows extends PureComponent<any, any> {\n  render() {\n    const { className = '', queries, ...handlers } = this.props;\n    return (\n      <div className={className}>\n        {queries.map((q, index) => <QueryRow key={q.key} index={index} query={q.query} {...handlers} />)}\n      </div>\n    );\n  }\n}\n","import React, { PureComponent } from 'react';\n// import TableModel from 'app/core/table_model';\n\nconst EMPTY_TABLE = {\n  columns: [],\n  rows: [],\n};\n\nexport default class Table extends PureComponent<any, any> {\n  render() {\n    const { className = '', data } = this.props;\n    const tableModel = data || EMPTY_TABLE;\n    return (\n      <table className={`${className} filter-table`}>\n        <thead>\n          <tr>{tableModel.columns.map(col => <th key={col.text}>{col.text}</th>)}</tr>\n        </thead>\n        <tbody>\n          {tableModel.rows.map((row, i) => <tr key={i}>{row.map((content, j) => <td key={j}>{content}</td>)}</tr>)}\n        </tbody>\n      </table>\n    );\n  }\n}\n","import React, { PureComponent } from 'react';\nimport moment from 'moment';\n\nimport * as dateMath from 'app/core/utils/datemath';\nimport * as rangeUtil from 'app/core/utils/rangeutil';\n\nconst DATE_FORMAT = 'YYYY-MM-DD HH:mm:ss';\n\nexport const DEFAULT_RANGE = {\n  from: 'now-6h',\n  to: 'now',\n};\n\nexport function parseTime(value, isUtc = false, asString = false) {\n  if (value.indexOf('now') !== -1) {\n    return value;\n  }\n  if (!isNaN(value)) {\n    const epoch = parseInt(value);\n    const m = isUtc ? moment.utc(epoch) : moment(epoch);\n    return asString ? m.format(DATE_FORMAT) : m;\n  }\n  return undefined;\n}\n\nexport default class TimePicker extends PureComponent<any, any> {\n  dropdownEl: any;\n  constructor(props) {\n    super(props);\n\n    const fromRaw = props.range ? props.range.from : DEFAULT_RANGE.from;\n    const toRaw = props.range ? props.range.to : DEFAULT_RANGE.to;\n    const range = {\n      from: parseTime(fromRaw),\n      to: parseTime(toRaw),\n    };\n    this.state = {\n      fromRaw: parseTime(fromRaw, props.isUtc, true),\n      isOpen: props.isOpen,\n      isUtc: props.isUtc,\n      rangeString: rangeUtil.describeTimeRange(range),\n      refreshInterval: '',\n      toRaw: parseTime(toRaw, props.isUtc, true),\n    };\n  }\n\n  move(direction) {\n    const { onChangeTime } = this.props;\n    const { fromRaw, toRaw } = this.state;\n    const range = {\n      from: dateMath.parse(fromRaw, false),\n      to: dateMath.parse(toRaw, true),\n    };\n\n    const timespan = (range.to.valueOf() - range.from.valueOf()) / 2;\n    let to, from;\n    if (direction === -1) {\n      to = range.to.valueOf() - timespan;\n      from = range.from.valueOf() - timespan;\n    } else if (direction === 1) {\n      to = range.to.valueOf() + timespan;\n      from = range.from.valueOf() + timespan;\n      if (to > Date.now() && range.to < Date.now()) {\n        to = Date.now();\n        from = range.from.valueOf();\n      }\n    } else {\n      to = range.to.valueOf();\n      from = range.from.valueOf();\n    }\n\n    const rangeString = rangeUtil.describeTimeRange(range);\n    // No need to convert to UTC again\n    to = moment(to);\n    from = moment(from);\n\n    this.setState(\n      {\n        rangeString,\n        fromRaw: from.format(DATE_FORMAT),\n        toRaw: to.format(DATE_FORMAT),\n      },\n      () => {\n        onChangeTime({ to, from });\n      }\n    );\n  }\n\n  handleChangeFrom = e => {\n    this.setState({\n      fromRaw: e.target.value,\n    });\n  };\n\n  handleChangeTo = e => {\n    this.setState({\n      toRaw: e.target.value,\n    });\n  };\n\n  handleClickApply = () => {\n    const { onChangeTime } = this.props;\n    const { toRaw, fromRaw } = this.state;\n    const range = {\n      from: dateMath.parse(fromRaw, false),\n      to: dateMath.parse(toRaw, true),\n    };\n    const rangeString = rangeUtil.describeTimeRange(range);\n    this.setState(\n      {\n        isOpen: false,\n        rangeString,\n      },\n      () => {\n        if (onChangeTime) {\n          onChangeTime(range);\n        }\n      }\n    );\n  };\n\n  handleClickLeft = () => this.move(-1);\n  handleClickPicker = () => {\n    this.setState(state => ({\n      isOpen: !state.isOpen,\n    }));\n  };\n  handleClickRight = () => this.move(1);\n  handleClickRefresh = () => {};\n  handleClickRelativeOption = range => {\n    const { onChangeTime } = this.props;\n    const rangeString = rangeUtil.describeTimeRange(range);\n    this.setState(\n      {\n        toRaw: range.to,\n        fromRaw: range.from,\n        isOpen: false,\n        rangeString,\n      },\n      () => {\n        if (onChangeTime) {\n          onChangeTime(range);\n        }\n      }\n    );\n  };\n\n  getTimeOptions() {\n    return rangeUtil.getRelativeTimesList({}, this.state.rangeString);\n  }\n\n  dropdownRef = el => {\n    this.dropdownEl = el;\n  };\n\n  renderDropdown() {\n    const { fromRaw, isOpen, toRaw } = this.state;\n    if (!isOpen) {\n      return null;\n    }\n    const timeOptions = this.getTimeOptions();\n    return (\n      <div ref={this.dropdownRef} className=\"gf-timepicker-dropdown\">\n        <div className=\"gf-timepicker-absolute-section\">\n          <h3 className=\"section-heading\">Custom range</h3>\n\n          <label className=\"small\">From:</label>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form max-width-28\">\n              <input\n                type=\"text\"\n                className=\"gf-form-input input-large timepicker-from\"\n                value={fromRaw}\n                onChange={this.handleChangeFrom}\n              />\n            </div>\n          </div>\n\n          <label className=\"small\">To:</label>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form max-width-28\">\n              <input\n                type=\"text\"\n                className=\"gf-form-input input-large timepicker-to\"\n                value={toRaw}\n                onChange={this.handleChangeTo}\n              />\n            </div>\n          </div>\n\n          {/* <label className=\"small\">Refreshing every:</label>\n          <div className=\"gf-form-inline\">\n            <div className=\"gf-form max-width-28\">\n              <select className=\"gf-form-input input-medium\" ng-options=\"f.value as f.text for f in ctrl.refresh.options\"></select>\n            </div>\n          </div> */}\n          <div className=\"gf-form\">\n            <button className=\"btn gf-form-btn btn-secondary\" onClick={this.handleClickApply}>\n              Apply\n            </button>\n          </div>\n        </div>\n\n        <div className=\"gf-timepicker-relative-section\">\n          <h3 className=\"section-heading\">Quick ranges</h3>\n          {Object.keys(timeOptions).map(section => {\n            const group = timeOptions[section];\n            return (\n              <ul key={section}>\n                {group.map(option => (\n                  <li className={option.active ? 'active' : ''} key={option.display}>\n                    <a onClick={() => this.handleClickRelativeOption(option)}>{option.display}</a>\n                  </li>\n                ))}\n              </ul>\n            );\n          })}\n        </div>\n      </div>\n    );\n  }\n\n  render() {\n    const { isUtc, rangeString, refreshInterval } = this.state;\n    return (\n      <div className=\"timepicker\">\n        <div className=\"navbar-buttons\">\n          <button className=\"btn navbar-button navbar-button--tight timepicker-left\" onClick={this.handleClickLeft}>\n            <i className=\"fa fa-chevron-left\" />\n          </button>\n          <button className=\"btn navbar-button gf-timepicker-nav-btn\" onClick={this.handleClickPicker}>\n            <i className=\"fa fa-clock-o\" />\n            <span className=\"timepicker-rangestring\">{rangeString}</span>\n            {isUtc ? <span className=\"gf-timepicker-utc\">UTC</span> : null}\n            {refreshInterval ? <span className=\"text-warning\">&nbsp; Refresh every {refreshInterval}</span> : null}\n          </button>\n          <button className=\"btn navbar-button navbar-button--tight timepicker-right\" onClick={this.handleClickRight}>\n            <i className=\"fa fa-chevron-right\" />\n          </button>\n        </div>\n        {this.renderDropdown()}\n      </div>\n    );\n  }\n}\n","import React from 'react';\n\nimport { Suggestion, SuggestionGroup } from './QueryField';\n\nfunction scrollIntoView(el: HTMLElement) {\n  if (!el || !el.offsetParent) {\n    return;\n  }\n  const container = el.offsetParent as HTMLElement;\n  if (el.offsetTop > container.scrollTop + container.offsetHeight || el.offsetTop < container.scrollTop) {\n    container.scrollTop = el.offsetTop - container.offsetTop;\n  }\n}\n\ninterface TypeaheadItemProps {\n  isSelected: boolean;\n  item: Suggestion;\n  onClickItem: (Suggestion) => void;\n}\n\nclass TypeaheadItem extends React.PureComponent<TypeaheadItemProps, {}> {\n  el: HTMLElement;\n\n  componentDidUpdate(prevProps) {\n    if (this.props.isSelected && !prevProps.isSelected) {\n      scrollIntoView(this.el);\n    }\n  }\n\n  getRef = el => {\n    this.el = el;\n  };\n\n  onClick = () => {\n    this.props.onClickItem(this.props.item);\n  };\n\n  render() {\n    const { isSelected, item } = this.props;\n    const className = isSelected ? 'typeahead-item typeahead-item__selected' : 'typeahead-item';\n    return (\n      <li ref={this.getRef} className={className} onClick={this.onClick}>\n        {item.detail || item.label}\n        {item.documentation && isSelected ? <div className=\"typeahead-item-hint\">{item.documentation}</div> : null}\n      </li>\n    );\n  }\n}\n\ninterface TypeaheadGroupProps {\n  items: Suggestion[];\n  label: string;\n  onClickItem: (Suggestion) => void;\n  selected: Suggestion;\n}\n\nclass TypeaheadGroup extends React.PureComponent<TypeaheadGroupProps, {}> {\n  render() {\n    const { items, label, selected, onClickItem } = this.props;\n    return (\n      <li className=\"typeahead-group\">\n        <div className=\"typeahead-group__title\">{label}</div>\n        <ul className=\"typeahead-group__list\">\n          {items.map(item => {\n            return (\n              <TypeaheadItem key={item.label} onClickItem={onClickItem} isSelected={selected === item} item={item} />\n            );\n          })}\n        </ul>\n      </li>\n    );\n  }\n}\n\ninterface TypeaheadProps {\n  groupedItems: SuggestionGroup[];\n  menuRef: any;\n  selectedItem: Suggestion | null;\n  onClickItem: (Suggestion) => void;\n}\nclass Typeahead extends React.PureComponent<TypeaheadProps, {}> {\n  render() {\n    const { groupedItems, menuRef, selectedItem, onClickItem } = this.props;\n    return (\n      <ul className=\"typeahead\" ref={menuRef}>\n        {groupedItems.map(g => (\n          <TypeaheadGroup key={g.label} onClickItem={onClickItem} selected={selectedItem} {...g} />\n        ))}\n      </ul>\n    );\n  }\n}\n\nexport default Typeahead;\n","import React, { PureComponent } from 'react';\n\nimport Explore from './Explore';\n\nexport default class Wrapper extends PureComponent<any, any> {\n  state = {\n    initialState: null,\n    split: false,\n  };\n\n  handleChangeSplit = (split, initialState) => {\n    this.setState({ split, initialState });\n  };\n\n  render() {\n    // State overrides for props from first Explore\n    const { initialState, split } = this.state;\n    return (\n      <div className=\"explore-wrapper\">\n        <Explore {...this.props} position=\"left\" onChangeSplit={this.handleChangeSplit} split={split} />\n        {split ? (\n          <Explore\n            {...this.props}\n            initialState={initialState}\n            onChangeSplit={this.handleChangeSplit}\n            position=\"right\"\n            split={split}\n          />\n        ) : null}\n      </div>\n    );\n  }\n}\n","const BRACES = {\n  '[': ']',\n  '{': '}',\n  '(': ')',\n};\n\nexport default function BracesPlugin() {\n  return {\n    onKeyDown(event, change) {\n      const { value } = change;\n      if (!value.isCollapsed) {\n        return undefined;\n      }\n\n      switch (event.key) {\n        case '{':\n        case '[': {\n          event.preventDefault();\n          // Insert matching braces\n          change\n            .insertText(`${event.key}${BRACES[event.key]}`)\n            .move(-1)\n            .focus();\n          return true;\n        }\n\n        case '(': {\n          event.preventDefault();\n          const text = value.anchorText.text;\n          const offset = value.anchorOffset;\n          const space = text.indexOf(' ', offset);\n          const length = space > 0 ? space : text.length;\n          const forward = length - offset;\n          // Insert matching braces\n          change\n            .insertText(event.key)\n            .move(forward)\n            .insertText(BRACES[event.key])\n            .move(-1 - forward)\n            .focus();\n          return true;\n        }\n\n        default: {\n          break;\n        }\n      }\n      return undefined;\n    },\n  };\n}\n","// Clears the rest of the line after the caret\nexport default function ClearPlugin() {\n  return {\n    onKeyDown(event, change) {\n      const { value } = change;\n      if (!value.isCollapsed) {\n        return undefined;\n      }\n\n      if (event.key === 'k' && event.ctrlKey) {\n        event.preventDefault();\n        const text = value.anchorText.text;\n        const offset = value.anchorOffset;\n        const length = text.length;\n        const forward = length - offset;\n        change.deleteForward(forward);\n        return true;\n      }\n      return undefined;\n    },\n  };\n}\n","function getIndent(text) {\n  let offset = text.length - text.trimLeft().length;\n  if (offset) {\n    let indent = text[0];\n    while (--offset) {\n      indent += text[0];\n    }\n    return indent;\n  }\n  return '';\n}\n\nexport default function NewlinePlugin() {\n  return {\n    onKeyDown(event, change) {\n      const { value } = change;\n      if (!value.isCollapsed) {\n        return undefined;\n      }\n\n      if (event.key === 'Enter' && event.shiftKey) {\n        event.preventDefault();\n\n        const { startBlock } = value;\n        const currentLineText = startBlock.text;\n        const indent = getIndent(currentLineText);\n\n        return change\n          .splitBlock()\n          .insertText(indent)\n          .focus();\n      }\n    },\n  };\n}\n","import React from 'react';\nimport Prism from 'prismjs';\n\nconst TOKEN_MARK = 'prism-token';\n\nexport function setPrismTokens(language, field, values, alias = 'variable') {\n  Prism.languages[language][field] = {\n    alias,\n    pattern: new RegExp(`(?:^|\\\\s)(${values.join('|')})(?:$|\\\\s)`),\n  };\n}\n\n/**\n * Code-highlighting plugin based on Prism and\n * https://github.com/ianstormtaylor/slate/blob/master/examples/code-highlighting/index.js\n *\n * (Adapted to handle nested grammar definitions.)\n */\n\nexport default function PrismPlugin({ definition, language }) {\n  if (definition) {\n    // Don't override exising modified definitions\n    Prism.languages[language] = Prism.languages[language] || definition;\n  }\n\n  return {\n    /**\n     * Render a Slate mark with appropiate CSS class names\n     *\n     * @param {Object} props\n     * @return {Element}\n     */\n\n    renderMark(props) {\n      const { children, mark } = props;\n      // Only apply spans to marks identified by this plugin\n      if (mark.type !== TOKEN_MARK) {\n        return undefined;\n      }\n      const className = `token ${mark.data.get('types')}`;\n      return <span className={className}>{children}</span>;\n    },\n\n    /**\n     * Decorate code blocks with Prism.js highlighting.\n     *\n     * @param {Node} node\n     * @return {Array}\n     */\n\n    decorateNode(node) {\n      if (node.type !== 'paragraph') {\n        return [];\n      }\n\n      const texts = node.getTexts().toArray();\n      const tstring = texts.map(t => t.text).join('\\n');\n      const grammar = Prism.languages[language];\n      const tokens = Prism.tokenize(tstring, grammar);\n      const decorations = [];\n      let startText = texts.shift();\n      let endText = startText;\n      let startOffset = 0;\n      let endOffset = 0;\n      let start = 0;\n\n      function processToken(token, acc?) {\n        // Accumulate token types down the tree\n        const types = `${acc || ''} ${token.type || ''} ${token.alias || ''}`;\n\n        // Add mark for token node\n        if (typeof token === 'string' || typeof token.content === 'string') {\n          startText = endText;\n          startOffset = endOffset;\n\n          const content = typeof token === 'string' ? token : token.content;\n          const newlines = content.split('\\n').length - 1;\n          const length = content.length - newlines;\n          const end = start + length;\n\n          let available = startText.text.length - startOffset;\n          let remaining = length;\n\n          endOffset = startOffset + remaining;\n\n          while (available < remaining) {\n            endText = texts.shift();\n            remaining = length - available;\n            available = endText.text.length;\n            endOffset = remaining;\n          }\n\n          // Inject marks from up the tree (acc) as well\n          if (typeof token !== 'string' || acc) {\n            const range = {\n              anchorKey: startText.key,\n              anchorOffset: startOffset,\n              focusKey: endText.key,\n              focusOffset: endOffset,\n              marks: [{ type: TOKEN_MARK, data: { types } }],\n            };\n\n            decorations.push(range);\n          }\n\n          start = end;\n        } else if (token.content && token.content.length) {\n          // Tokens can be nested\n          for (const subToken of token.content) {\n            processToken(subToken, types);\n          }\n        }\n      }\n\n      // Process top-level tokens\n      for (const token of tokens) {\n        processToken(token);\n      }\n\n      return decorations;\n    },\n  };\n}\n","/* tslint:disable max-line-length */\n\nexport const OPERATORS = ['by', 'group_left', 'group_right', 'ignoring', 'on', 'offset', 'without'];\n\nconst AGGREGATION_OPERATORS = [\n  {\n    label: 'sum',\n    insertText: 'sum()',\n    documentation: 'Calculate sum over dimensions',\n  },\n  {\n    label: 'min',\n    insertText: 'min()',\n    documentation: 'Select minimum over dimensions',\n  },\n  {\n    label: 'max',\n    insertText: 'max()',\n    documentation: 'Select maximum over dimensions',\n  },\n  {\n    label: 'avg',\n    insertText: 'avg()',\n    documentation: 'Calculate the average over dimensions',\n  },\n  {\n    label: 'stddev',\n    insertText: 'stddev()',\n    documentation: 'Calculate population standard deviation over dimensions',\n  },\n  {\n    label: 'stdvar',\n    insertText: 'stdvar()',\n    documentation: 'Calculate population standard variance over dimensions',\n  },\n  {\n    label: 'count',\n    insertText: 'count()',\n    documentation: 'Count number of elements in the vector',\n  },\n  {\n    label: 'count_values',\n    insertText: 'count_values()',\n    documentation: 'Count number of elements with the same value',\n  },\n  {\n    label: 'bottomk',\n    insertText: 'bottomk()',\n    documentation: 'Smallest k elements by sample value',\n  },\n  {\n    label: 'topk',\n    insertText: 'topk()',\n    documentation: 'Largest k elements by sample value',\n  },\n  {\n    label: 'quantile',\n    insertText: 'quantile()',\n    documentation: 'Calculate -quantile (0    1) over dimensions',\n  },\n];\n\nexport const FUNCTIONS = [\n  ...AGGREGATION_OPERATORS,\n  {\n    insertText: 'abs()',\n    label: 'abs',\n    detail: 'abs(v instant-vector)',\n    documentation: 'Returns the input vector with all sample values converted to their absolute value.',\n  },\n  {\n    insertText: 'absent()',\n    label: 'absent',\n    detail: 'absent(v instant-vector)',\n    documentation:\n      'Returns an empty vector if the vector passed to it has any elements and a 1-element vector with the value 1 if the vector passed to it has no elements. This is useful for alerting on when no time series exist for a given metric name and label combination.',\n  },\n  {\n    insertText: 'ceil()',\n    label: 'ceil',\n    detail: 'ceil(v instant-vector)',\n    documentation: 'Rounds the sample values of all elements in `v` up to the nearest integer.',\n  },\n  {\n    insertText: 'changes()',\n    label: 'changes',\n    detail: 'changes(v range-vector)',\n    documentation:\n      'For each input time series, `changes(v range-vector)` returns the number of times its value has changed within the provided time range as an instant vector.',\n  },\n  {\n    insertText: 'clamp_max()',\n    label: 'clamp_max',\n    detail: 'clamp_max(v instant-vector, max scalar)',\n    documentation: 'Clamps the sample values of all elements in `v` to have an upper limit of `max`.',\n  },\n  {\n    insertText: 'clamp_min()',\n    label: 'clamp_min',\n    detail: 'clamp_min(v instant-vector, min scalar)',\n    documentation: 'Clamps the sample values of all elements in `v` to have a lower limit of `min`.',\n  },\n  {\n    insertText: 'count_scalar()',\n    label: 'count_scalar',\n    detail: 'count_scalar(v instant-vector)',\n    documentation:\n      'Returns the number of elements in a time series vector as a scalar. This is in contrast to the `count()` aggregation operator, which always returns a vector (an empty one if the input vector is empty) and allows grouping by labels via a `by` clause.',\n  },\n  {\n    insertText: 'day_of_month()',\n    label: 'day_of_month',\n    detail: 'day_of_month(v=vector(time()) instant-vector)',\n    documentation: 'Returns the day of the month for each of the given times in UTC. Returned values are from 1 to 31.',\n  },\n  {\n    insertText: 'day_of_week()',\n    label: 'day_of_week',\n    detail: 'day_of_week(v=vector(time()) instant-vector)',\n    documentation:\n      'Returns the day of the week for each of the given times in UTC. Returned values are from 0 to 6, where 0 means Sunday etc.',\n  },\n  {\n    insertText: 'days_in_month()',\n    label: 'days_in_month',\n    detail: 'days_in_month(v=vector(time()) instant-vector)',\n    documentation:\n      'Returns number of days in the month for each of the given times in UTC. Returned values are from 28 to 31.',\n  },\n  {\n    insertText: 'delta()',\n    label: 'delta',\n    detail: 'delta(v range-vector)',\n    documentation:\n      'Calculates the difference between the first and last value of each time series element in a range vector `v`, returning an instant vector with the given deltas and equivalent labels. The delta is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if the sample values are all integers.',\n  },\n  {\n    insertText: 'deriv()',\n    label: 'deriv',\n    detail: 'deriv(v range-vector)',\n    documentation:\n      'Calculates the per-second derivative of the time series in a range vector `v`, using simple linear regression.',\n  },\n  {\n    insertText: 'drop_common_labels()',\n    label: 'drop_common_labels',\n    detail: 'drop_common_labels(instant-vector)',\n    documentation: 'Drops all labels that have the same name and value across all series in the input vector.',\n  },\n  {\n    insertText: 'exp()',\n    label: 'exp',\n    detail: 'exp(v instant-vector)',\n    documentation:\n      'Calculates the exponential function for all elements in `v`.\\nSpecial cases are:\\n* `Exp(+Inf) = +Inf` \\n* `Exp(NaN) = NaN`',\n  },\n  {\n    insertText: 'floor()',\n    label: 'floor',\n    detail: 'floor(v instant-vector)',\n    documentation: 'Rounds the sample values of all elements in `v` down to the nearest integer.',\n  },\n  {\n    insertText: 'histogram_quantile()',\n    label: 'histogram_quantile',\n    detail: 'histogram_quantile( float, b instant-vector)',\n    documentation:\n      'Calculates the -quantile (0    1) from the buckets `b` of a histogram. The samples in `b` are the counts of observations in each bucket. Each sample must have a label `le` where the label value denotes the inclusive upper bound of the bucket. (Samples without such a label are silently ignored.) The histogram metric type automatically provides time series with the `_bucket` suffix and the appropriate labels.',\n  },\n  {\n    insertText: 'holt_winters()',\n    label: 'holt_winters',\n    detail: 'holt_winters(v range-vector, sf scalar, tf scalar)',\n    documentation:\n      'Produces a smoothed value for time series based on the range in `v`. The lower the smoothing factor `sf`, the more importance is given to old data. The higher the trend factor `tf`, the more trends in the data is considered. Both `sf` and `tf` must be between 0 and 1.',\n  },\n  {\n    insertText: 'hour()',\n    label: 'hour',\n    detail: 'hour(v=vector(time()) instant-vector)',\n    documentation: 'Returns the hour of the day for each of the given times in UTC. Returned values are from 0 to 23.',\n  },\n  {\n    insertText: 'idelta()',\n    label: 'idelta',\n    detail: 'idelta(v range-vector)',\n    documentation:\n      'Calculates the difference between the last two samples in the range vector `v`, returning an instant vector with the given deltas and equivalent labels.',\n  },\n  {\n    insertText: 'increase()',\n    label: 'increase',\n    detail: 'increase(v range-vector)',\n    documentation:\n      'Calculates the increase in the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. The increase is extrapolated to cover the full time range as specified in the range vector selector, so that it is possible to get a non-integer result even if a counter increases only by integer increments.',\n  },\n  {\n    insertText: 'irate()',\n    label: 'irate',\n    detail: 'irate(v range-vector)',\n    documentation:\n      'Calculates the per-second instant rate of increase of the time series in the range vector. This is based on the last two data points. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for.',\n  },\n  {\n    insertText: 'label_replace()',\n    label: 'label_replace',\n    detail: 'label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)',\n    documentation:\n      \"For each timeseries in `v`, `label_replace(v instant-vector, dst_label string, replacement string, src_label string, regex string)`  matches the regular expression `regex` against the label `src_label`.  If it matches, then the timeseries is returned with the label `dst_label` replaced by the expansion of `replacement`. `$1` is replaced with the first matching subgroup, `$2` with the second etc. If the regular expression doesn't match then the timeseries is returned unchanged.\",\n  },\n  {\n    insertText: 'ln()',\n    label: 'ln',\n    detail: 'ln(v instant-vector)',\n    documentation:\n      'calculates the natural logarithm for all elements in `v`.\\nSpecial cases are:\\n * `ln(+Inf) = +Inf`\\n * `ln(0) = -Inf`\\n * `ln(x < 0) = NaN`\\n * `ln(NaN) = NaN`',\n  },\n  {\n    insertText: 'log2()',\n    label: 'log2',\n    detail: 'log2(v instant-vector)',\n    documentation:\n      'Calculates the binary logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.',\n  },\n  {\n    insertText: 'log10()',\n    label: 'log10',\n    detail: 'log10(v instant-vector)',\n    documentation:\n      'Calculates the decimal logarithm for all elements in `v`. The special cases are equivalent to those in `ln`.',\n  },\n  {\n    insertText: 'minute()',\n    label: 'minute',\n    detail: 'minute(v=vector(time()) instant-vector)',\n    documentation:\n      'Returns the minute of the hour for each of the given times in UTC. Returned values are from 0 to 59.',\n  },\n  {\n    insertText: 'month()',\n    label: 'month',\n    detail: 'month(v=vector(time()) instant-vector)',\n    documentation:\n      'Returns the month of the year for each of the given times in UTC. Returned values are from 1 to 12, where 1 means January etc.',\n  },\n  {\n    insertText: 'predict_linear()',\n    label: 'predict_linear',\n    detail: 'predict_linear(v range-vector, t scalar)',\n    documentation:\n      'Predicts the value of time series `t` seconds from now, based on the range vector `v`, using simple linear regression.',\n  },\n  {\n    insertText: 'rate()',\n    label: 'rate',\n    detail: 'rate(v range-vector)',\n    documentation:\n      \"Calculates the per-second average rate of increase of the time series in the range vector. Breaks in monotonicity (such as counter resets due to target restarts) are automatically adjusted for. Also, the calculation extrapolates to the ends of the time range, allowing for missed scrapes or imperfect alignment of scrape cycles with the range's time period.\",\n  },\n  {\n    insertText: 'resets()',\n    label: 'resets',\n    detail: 'resets(v range-vector)',\n    documentation:\n      'For each input time series, `resets(v range-vector)` returns the number of counter resets within the provided time range as an instant vector. Any decrease in the value between two consecutive samples is interpreted as a counter reset.',\n  },\n  {\n    insertText: 'round()',\n    label: 'round',\n    detail: 'round(v instant-vector, to_nearest=1 scalar)',\n    documentation:\n      'Rounds the sample values of all elements in `v` to the nearest integer. Ties are resolved by rounding up. The optional `to_nearest` argument allows specifying the nearest multiple to which the sample values should be rounded. This multiple may also be a fraction.',\n  },\n  {\n    insertText: 'scalar()',\n    label: 'scalar',\n    detail: 'scalar(v instant-vector)',\n    documentation:\n      'Given a single-element input vector, `scalar(v instant-vector)` returns the sample value of that single element as a scalar. If the input vector does not have exactly one element, `scalar` will return `NaN`.',\n  },\n  {\n    insertText: 'sort()',\n    label: 'sort',\n    detail: 'sort(v instant-vector)',\n    documentation: 'Returns vector elements sorted by their sample values, in ascending order.',\n  },\n  {\n    insertText: 'sort_desc()',\n    label: 'sort_desc',\n    detail: 'sort_desc(v instant-vector)',\n    documentation: 'Returns vector elements sorted by their sample values, in descending order.',\n  },\n  {\n    insertText: 'sqrt()',\n    label: 'sqrt',\n    detail: 'sqrt(v instant-vector)',\n    documentation: 'Calculates the square root of all elements in `v`.',\n  },\n  {\n    insertText: 'time()',\n    label: 'time',\n    detail: 'time()',\n    documentation:\n      'Returns the number of seconds since January 1, 1970 UTC. Note that this does not actually return the current time, but the time at which the expression is to be evaluated.',\n  },\n  {\n    insertText: 'vector()',\n    label: 'vector',\n    detail: 'vector(s scalar)',\n    documentation: 'Returns the scalar `s` as a vector with no labels.',\n  },\n  {\n    insertText: 'year()',\n    label: 'year',\n    detail: 'year(v=vector(time()) instant-vector)',\n    documentation: 'Returns the year for each of the given times in UTC.',\n  },\n  {\n    insertText: 'avg_over_time()',\n    label: 'avg_over_time',\n    detail: 'avg_over_time(range-vector)',\n    documentation: 'The average value of all points in the specified interval.',\n  },\n  {\n    insertText: 'min_over_time()',\n    label: 'min_over_time',\n    detail: 'min_over_time(range-vector)',\n    documentation: 'The minimum value of all points in the specified interval.',\n  },\n  {\n    insertText: 'max_over_time()',\n    label: 'max_over_time',\n    detail: 'max_over_time(range-vector)',\n    documentation: 'The maximum value of all points in the specified interval.',\n  },\n  {\n    insertText: 'sum_over_time()',\n    label: 'sum_over_time',\n    detail: 'sum_over_time(range-vector)',\n    documentation: 'The sum of all values in the specified interval.',\n  },\n  {\n    insertText: 'count_over_time()',\n    label: 'count_over_time',\n    detail: 'count_over_time(range-vector)',\n    documentation: 'The count of all values in the specified interval.',\n  },\n  {\n    insertText: 'quantile_over_time()',\n    label: 'quantile_over_time',\n    detail: 'quantile_over_time(scalar, range-vector)',\n    documentation: 'The -quantile (0    1) of the values in the specified interval.',\n  },\n  {\n    insertText: 'stddev_over_time()',\n    label: 'stddev_over_time',\n    detail: 'stddev_over_time(range-vector)',\n    documentation: 'The population standard deviation of the values in the specified interval.',\n  },\n  {\n    insertText: 'stdvar_over_time()',\n    label: 'stdvar_over_time',\n    detail: 'stdvar_over_time(range-vector)',\n    documentation: 'The population standard variance of the values in the specified interval.',\n  },\n];\n\nconst tokenizer = {\n  comment: {\n    pattern: /(^|[^\\n])#.*/,\n    lookbehind: true,\n  },\n  'context-aggregation': {\n    pattern: /((by|without)\\s*)\\([^)]*\\)/, // by ()\n    lookbehind: true,\n    inside: {\n      'label-key': {\n        pattern: /[^,\\s][^,]*[^,\\s]*/,\n        alias: 'attr-name',\n      },\n    },\n  },\n  'context-labels': {\n    pattern: /\\{[^}]*(?=})/,\n    inside: {\n      'label-key': {\n        pattern: /[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/,\n        alias: 'attr-name',\n      },\n      'label-value': {\n        pattern: /\"(?:\\\\.|[^\\\\\"])*\"/,\n        greedy: true,\n        alias: 'attr-value',\n      },\n    },\n  },\n  function: new RegExp(`\\\\b(?:${FUNCTIONS.map(f => f.label).join('|')})(?=\\\\s*\\\\()`, 'i'),\n  'context-range': [\n    {\n      pattern: /\\[[^\\]]*(?=])/, // [1m]\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n    {\n      pattern: /(offset\\s+)\\w+/, // offset 1m\n      lookbehind: true,\n      inside: {\n        'range-duration': {\n          pattern: /\\b\\d+[smhdwy]\\b/i,\n          alias: 'number',\n        },\n      },\n    },\n  ],\n  number: /\\b-?\\d+((\\.\\d*)?([eE][+-]?\\d+)?)?\\b/,\n  operator: new RegExp(`/[-+*/=%^~]|&&?|\\\\|?\\\\||!=?|<(?:=>?|<|>)?|>[>=]?|\\\\b(?:${OPERATORS.join('|')})\\\\b`, 'i'),\n  punctuation: /[{};()`,.]/,\n};\n\nexport default tokenizer;\n","export default function RunnerPlugin({ handler }) {\n  return {\n    onKeyDown(event) {\n      // Handle enter\n      if (handler && event.key === 'Enter' && !event.shiftKey) {\n        // Submit on Enter\n        event.preventDefault();\n        handler(event);\n        return true;\n      }\n      return undefined;\n    },\n  };\n}\n","// Node.closest() polyfill\nif ('Element' in window && !Element.prototype.closest) {\n  Element.prototype.closest = function(s) {\n    const matches = (this.document || this.ownerDocument).querySelectorAll(s);\n    let el = this;\n    let i;\n    // eslint-disable-next-line\n    do {\n      i = matches.length;\n      // eslint-disable-next-line\n      while (--i >= 0 && matches.item(i) !== el) {}\n    } while (i < 0 && (el = el.parentElement));\n    return el;\n  };\n}\n\nexport function getPreviousCousin(node, selector) {\n  let sibling = node.parentElement.previousSibling;\n  let el;\n  while (sibling) {\n    el = sibling.querySelector(selector);\n    if (el) {\n      return el;\n    }\n    sibling = sibling.previousSibling;\n  }\n  return undefined;\n}\n\nexport function getNextCharacter(global = window) {\n  const selection = global.getSelection();\n  if (!selection.anchorNode) {\n    return null;\n  }\n\n  const range = selection.getRangeAt(0);\n  const text = selection.anchorNode.textContent;\n  const offset = range.startOffset;\n  return text.substr(offset, 1);\n}\n","export const RATE_RANGES = ['1m', '5m', '10m', '30m', '1h'];\n\nexport function processLabels(labels) {\n  const values = {};\n  labels.forEach(l => {\n    const { __name__, ...rest } = l;\n    Object.keys(rest).forEach(key => {\n      if (!values[key]) {\n        values[key] = [];\n      }\n      if (values[key].indexOf(rest[key]) === -1) {\n        values[key].push(rest[key]);\n      }\n    });\n  });\n  return { values, keys: Object.keys(values) };\n}\n\n// Strip syntax chars\nexport const cleanText = s => s.replace(/[{}[\\]=\"(),!~+\\-*/^%]/g, '').trim();\n","export function generateQueryKey(index = 0) {\n  return `Q-${Date.now()}-${Math.random()}-${index}`;\n}\n\nexport function ensureQueries(queries?) {\n  if (queries && typeof queries === 'object' && queries.length > 0 && typeof queries[0] === 'string') {\n    return queries.map((query, i) => ({ key: generateQueryKey(i), query }));\n  }\n  return [{ key: generateQueryKey(), query: '' }];\n}\n\nexport function hasQuery(queries) {\n  return queries.some(q => q.query);\n}\n"],"mappings":";;;;;;;;;;;;;;;AAAA;AAEA;AAEA;AAAA;AAAA;AAAA;AAIA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;;AAwBA;AAjCA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAyBA;AAAA;AAGA;AAAA;AAoFA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;;;;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuFA;AACA;AACA;AACA;AAxQA;AACA;;AAuBA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAAA;;AAEA;;AAAA;;;AAEA;AACA;;AAAA;;;AAEA;;;AAEA;;;;;;AAEA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AACA;AACA;AACA;AACA;;;;AAGA;;AAAA;AACA;;;;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAGA;AAgGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAEA;;AAAA;AACA;AACA;AACA;;;;AAEA;AACA;AACA;;;;;;AAEA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAEA;;AAAA;AACA;AACA;AACA;;;;AAEA;AACA;AACA;;;;;;AAEA;AAEA;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAGA;;AAAA;AACA;AACA;AACA;;;;AAEA;AACA;AACA;;;;;;AAEA;AAOA;AACA;AACA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAIA;AAKA;AAEA;AAUA;AACA;AAEA;AAKA;AACA;AAKA;AAKA;AAMA;AACA;AACA;;AACA;AAEA;AAIA;AAEA;AAIA;;AACA;AAAA;AAGA;AAEA;AAQA;AACA;AACA;AASA;AACA;AAMA;AACA;AAAA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACreA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAEA;AAAA;AAAA;;AAiEA;AAhEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;ACvIA;AAEA;AAAA;AAAA;AAEA;AACA;AAEA;AALA;AASA;AAAA;AAAA;;AAUA;AATA;AACA;AACA;AACA;AAKA;AACA;AAAA;;;;;;;;;;;;;;;;;;;ACrBA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AA2BA;AA1BA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAMA;;AAEA;AAKA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA2BA;AAAA;AAGA;AAAA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAkIA;AACA;AACA;AACA;AACA;AACA;AAtLA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AAmCA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;;;;;;AACA;;;;AAEA;;AAAA;AACA;;AAAA;AACA;AACA;AAIA;AAIA;;;;AAEA;;;;;;AAEA;AAEA;;;;;;AACA;;;;AAEA;;AAAA;AACA;;AAAA;AACA;AACA;AAIA;AAIA;;;;AAEA;;;;;;AAEA;AAEA;;;;;;AACA;;;;AAEA;;AAAA;AACA;;AAAA;AACA;;;;AAEA;;;;;;AAEA;AAEA;AACA;AAWA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnVA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AAEA;AAwGA;AAAA;AAKA;AAAA;AAmCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AACA;AAwCA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAQA;AAnUA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA0FA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAyKA;AACA;AAEA;AACA;AAaA;AACA;AAAA;AAEA;AAAA;AAGA;AAAA;AAEA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;AC9fA;AAEA;AAEA;AAAA;AACA;AAAA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAnCA;AACA;AACA;AACA;;AACA;AAiCA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAUA;AACA;AAAA;AAEA;AAAA;AAAA;;AASA;AARA;AACA;AACA;AAKA;AACA;AAAA;;;;;;;;;;;;;;;;;;;AChFA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AAeA;AAdA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AA6DA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AA3HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AA6DA;AACA;AACA;AAMA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AAeA;AACA;AAMA;AACA;AACA;AACA;AACA;AAIA;AAKA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAAA;AAEA;AACA;AAGA;AAGA;AACA;AAAA;;;;;;;;;;;;;;;;;;;ACpPA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAAA;AAAA;AAAA;AASA;AACA;AACA;AAEA;AACA;AACA;;AAYA;AAxBA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AASA;AAAA;AAAA;;AAgBA;AAfA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAIA;AACA;AAAA;AAQA;AAAA;AAAA;;AAWA;AAVA;AACA;AACA;AAOA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;AC7FA;AAEA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAoBA;AAlBA;AACA;AACA;AACA;AAEA;AACA;AAWA;AACA;AAAA;;;;;;;;;;;;;;AChCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC1HA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;ACvaA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACvCA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;A","sourceRoot":""}